export default {
  async fetch(request, env) {
    const ip = request.headers.get("CF-Connecting-IP") || "";

    let ptr = null;
    let trustedByIp = false;
    let trustedByPtr = false;
    let isTrusted = false;

    try {
      ptr = await getPtr(ip);
      const trust = await getTrustFlags(env, ip, ptr);
      trustedByIp = trust.trustedByIp;
      trustedByPtr = trust.trustedByPtr;
      isTrusted = trustedByIp || trustedByPtr;
    } catch (e) {
      isTrusted = false;
    }

    const siaValue = isTrusted ? "approve" : "deny";

    if (!isTrusted) {
      return new Response("403 Forbidden", {
        status: 403,
        headers: { "content-type": "text/plain" }
      });
    }

    const originRequestHeaders = new Headers(request.headers);
    originRequestHeaders.set("SIAList", siaValue);

    const originRequest = new Request(request, {
      headers: originRequestHeaders
    });

    return fetch(originRequest);
  }
};

async function getTrustFlags(env, ip, ptr) {
  const out = { trustedByIp: false, trustedByPtr: false };
  const kv = env.SIAList_trusted_clients;
  if (!kv) return out;

  // IP exact match
  if (ip) {
    const v = await kv.get(`ip:${ip}`);
    if (v !== null) {
      const norm = v.trim().toLowerCase();
      out.trustedByIp = norm === "1" || norm === "true";
    }
  }

  // PTR exact + wildcard suffix match
  if (ptr) {
    const vFull = await kv.get(`ptr:${ptr}`);
    if (vFull !== null) {
      const norm = vFull.trim().toLowerCase();
      out.trustedByPtr = norm === "1" || norm === "true";
    }

    if (!out.trustedByPtr) {
      const parts = ptr.split(".");
      for (let i = 1; i < parts.length - 1; i++) {
        const suffix = parts.slice(i).join(".");
        const key = `ptr:.${suffix}`;

        const vSuffix = await kv.get(key);
        if (vSuffix !== null) {
          const norm = vSuffix.trim().toLowerCase();
          if (norm === "1" || norm === "true") {
            out.trustedByPtr = true;
            break;
          }
        }
      }
    }
  }

  return out;
}

async function getPtr(ip) {
  if (!ip) return null;

  const queryName = ip.includes(":") ? ip6ToArpa(ip) : ip4ToArpa(ip);

  const resp = await fetch(
    `https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(
      queryName
    )}&type=PTR`,
    { headers: { accept: "application/dns-json" } }
  );

  if (!resp.ok) return null;
  const json = await resp.json();
  if (!json.Answer || json.Answer.length === 0) return null;

  return json.Answer[0].data.replace(/\.$/, "");
}

function ip4ToArpa(ip) {
  const parts = ip.split(".");
  return parts.length === 4
    ? parts.reverse().join(".") + ".in-addr.arpa"
    : ip;
}

function ip6ToArpa(ip) {
  const parts = ip.split("::");
  if (parts.length > 2) return ip;

  const head = parts[0] ? parts[0].split(":") : [];
  const tail = parts[1] ? parts[1].split(":") : [];
  const missing = 8 - (head.length + tail.length);
  const zeros = Array(missing).fill("0");

  const full = [...head, ...zeros, ...tail]
    .map(h => h.padStart(4, "0"))
    .join("");

  return full.split("").reverse().join(".") + ".ip6.arpa";
}

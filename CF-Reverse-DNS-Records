// Toggle this to true only when you want to debug.
const DEBUG_MODE = false;

export default {
  async fetch(request, env) {
    const ip = request.headers.get("CF-Connecting-IP") || "";
    const url = new URL(request.url);

    let ptr = null;
    let trustedByIp = false;
    let trustedByPtr = false;
    let isTrusted = false;
    let kvBound = false;
    let matchedKey = null;
    let matchedValue = null;

    try {
      ptr = await getPtr(ip);
      const trust = await getTrustFlags(env, ip, ptr);
      trustedByIp = trust.trustedByIp;
      trustedByPtr = trust.trustedByPtr;
      kvBound = trust.kvBound;
      matchedKey = trust.matchedKey;
      matchedValue = trust.matchedValue;
      isTrusted = trustedByIp || trustedByPtr;
    } catch (e) {
      isTrusted = false;
    }

    const siaValue = isTrusted ? "approve" : "deny";

    // ---------- PRODUCTION DEBUG WRAPPER ----------
    // Only active when DEBUG_MODE = true AND ?sia_debug=1 is present.
    if (DEBUG_MODE && url.searchParams.get("sia_debug") === "1") {
      const debugBody = {
        ip,
        ptr,
        trustedByIp,
        trustedByPtr,
        isTrusted,
        siaValue,
        kvBound,
        matchedKey,
        matchedValue
      };

      const status = isTrusted ? 200 : 403;

      return new Response(JSON.stringify(debugBody, null, 2), {
        status,
        headers: { "content-type": "application/json" }
      });
    }
    // ---------- END DEBUG WRAPPER ----------

    // If NOT trusted: block at the edge, no SIAList to browser.
    if (!isTrusted) {
      return new Response("403 Forbidden", {
        status: 403,
        headers: { "content-type": "text/plain" }
      });
    }

    // If trusted: forward to origin, tagging REQUEST with SIAList for logging.
    const originRequestHeaders = new Headers(request.headers);
    originRequestHeaders.set("SIAList", siaValue); // "approve"

    const originRequest = new Request(request, {
      headers: originRequestHeaders
    });

    return fetch(originRequest);
  }
};

async function getTrustFlags(env, ip, ptr) {
  const out = {
    trustedByIp: false,
    trustedByPtr: false,
    kvBound: false,
    matchedKey: null,
    matchedValue: null
  };

  const kv = env.SIAList_trusted_clients;
  if (!kv) return out;
  out.kvBound = true;

  // ----- IP exact match: ip:<address> -----
  if (ip) {
    const ipKey = `ip:${ip}`;
    const vIp = await kv.get(ipKey);
    if (vIp !== null) {
      const norm = vIp.trim().toLowerCase();
      if (norm === "1" || norm === "true") {
        out.trustedByIp = true;
        out.matchedKey = ipKey;
        out.matchedValue = vIp;
        return out; // IP match wins; no need to keep checking
      }
    }
  }

  // ----- PTR: exact + leading-dot suffix: ptr:<full>, ptr:.<suffix> -----
  if (ptr) {
    // 1) Exact PTR hostname
    let ptrKey = `ptr:${ptr}`;
    let vFull = await kv.get(ptrKey);
    if (vFull !== null) {
      const norm = vFull.trim().toLowerCase();
      if (norm === "1" || norm === "true") {
        out.trustedByPtr = true;
        out.matchedKey = ptrKey;
        out.matchedValue = vFull;
        return out;
      }
    }

    // 2) Suffix wildcards: ptr:.<suffix>
    const parts = ptr.split(".");
    for (let i = 1; i < parts.length - 1; i++) {
      const suffix = parts.slice(i).join(".");
      ptrKey = `ptr:.${suffix}`;
      const vSuffix = await kv.get(ptrKey);
      if (vSuffix !== null) {
        const norm = vSuffix.trim().toLowerCase();
        if (norm === "1" || norm === "true") {
          out.trustedByPtr = true;
          out.matchedKey = ptrKey;
          out.matchedValue = vSuffix;
          return out;
        }
      }
    }
  }

  return out;
}

async function getPtr(ip) {
  if (!ip) return null;

  const queryName = ip.includes(":") ? ip6ToArpa(ip) : ip4ToArpa(ip);

  const resp = await fetch(
    `https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(
      queryName
    )}&type=PTR`,
    { headers: { accept: "application/dns-json" } }
  );

  if (!resp.ok) return null;
  const json = await resp.json();
  if (!json.Answer || json.Answer.length === 0) return null;

  return json.Answer[0].data.replace(/\.$/, "");
}

function ip4ToArpa(ip) {
  const parts = ip.split(".");
  return parts.length === 4
    ? parts.reverse().join(".") + ".in-addr.arpa"
    : ip;
}

function ip6ToArpa(ip) {
  const parts = ip.split("::");
  if (parts.length > 2) return ip;

  const head = parts[0] ? parts[0].split(":") : [];
  const tail = parts[1] ? parts[1].split(":") : [];
  const missing = 8 - (head.length + tail.length);
  const zeros = Array(missing).fill("0");

  const full = [...head, ...zeros, ...tail]
    .map(h => h.padStart(4, "0"))
    .join("");

  return full.split("").reverse().join(".") + ".ip6.arpa";
}
